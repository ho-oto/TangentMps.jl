var documenterSearchIndex = {"docs":
[{"location":"#TangentMps.jl-1","page":"Home","title":"TangentMps.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [TangentMps]","category":"page"},{"location":"#TangentMps.al_from_ac_and_c-Tuple{AbstractArray{T,3} where T,AbstractArray{T,2} where T}","page":"Home","title":"TangentMps.al_from_ac_and_c","text":"al_from_ac_and_c(AC, C)\n\nCompute AL which satisfies mul_matrix_from_right(AL, C) ≈ AC\n\nReturn values:\n\nAL, ϵL = al_from_ac_and_c(AC, C)\n\nwhere ϵL = norm(mul_matrix_from_right(AL, C) - AC)\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.ar_from_ac_and_c-Tuple{AbstractArray{T,3} where T,AbstractArray{T,2} where T}","page":"Home","title":"TangentMps.ar_from_ac_and_c","text":"ar_from_ac_and_c(AC, C)\n\nCompute AR which satisfies mul_matrix_from_left(AR, C) ≈ AC\n\nReturn values:\n\nAR, ϵR = ar_from_ac_and_c(AC, C)\n\nwhere ϵR = norm(mul_matrix_from_left(AR, C) - AC)\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.ibcleft-Tuple{Any,Any,Any}","page":"Home","title":"TangentMps.ibcleft","text":"ibcleft(O, AL, C; kwargs...)\n\nCompute left infinite boundary condition, defined by\n\n   ┌────────┐   ┌────────┐      ┌─            ┌────────┐    ─┐ P\n┌──┤   AL   ├───┤   AL   ├───  ┌┘          ───┤   AL   ├───  └┐  ───\n│  └────┬───┘   └────┬───┘     │   ┌┐         └────┬───┘      │\n│       .────────────┴.        │  ─┘│              │          │\n│      (       O       )       │    │  ───         │          │\n│       `────────────┬'        │    │              │          │\n│  ┌────┴───┐   ┌────┴───┐     │  ──┴──       ┌────┴───┐      │\n└──┤conj(AL)├───┤conj(AL)├───  └┐          ───┤conj(AL)├───  ┌┘  ───\n   └────────┘   └────────┘      └─            └────────┘    ─┘\n\nReturn values:\n\nibc, info = ibcleft(O, AL, C)\n\nArguments:\n\nO: Hamiltonian (only two-site operator is supported)\nAL: left-canonical tensor of mixed-canonical uniform MPS representation\nC: center matrix of mixed-canonical uniform MPS representation\n\nIf O, AL and C is AbstractArray oblect, nothing have to be done. The following methods should be defined:\n\nTangentMps.transfer_from_left(X, O, AL)\nTangentMps.transfer_from_left(X, O, (AL, AL))\nTangentMps.similar_normalized_eye(X)\nBase.*(X, Y)\nBase.*(x::Number, X)\nBase.+(X, Y)\nBase.adjoint(X)\nBase.eltype(X)\nBase.similar(X, [T::Type<:Number])\nBase.fill!(X, α::Number)\nBase.copyto!(X, Y)\nLinearAlgebra.mul!(X, Y, α::Number)\nLinearAlgebra.rmul!(X, α::Number)\nLinearAlgebra.axpy!(α::Number, X, Y)\nLinearAlgebra.axpby!(α::Number, X, β::Number, Y)\nLinearAlgebra.tr(X)\nLinearAlgebra.dot(X,Y)\nLinearAlgebra.norm(X)\n\nwhere typeof(X) == typeof(Y) == typeof(C) is satisfied.\n\nKeyword arguments:\n\nKeyword arguments are passed to KrylovKit.linsolve used in ibc_left.\n\natol::Real: the requested accuracy, i.e. absolute tolerance, on the norm of the   residual.\nrtol::Real: the requested accuracy on the norm of the residual, relative to the norm   of the right hand side b.\ntol::Real: the requested accuracy on the norm of the residual which is actually used,   but which defaults to max(atol, rtol*norm(b)). So either atol and rtol or directly   use tol (in which case the value of atol and rtol will be ignored).\nkrylovdim::Integer: the maximum dimension of the Krylov subspace that will be   constructed.\nmaxiter::Integer: the number of times the Krylov subspace can be rebuilt; see below for   further details on the algorithms.\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.ibcright-Tuple{Any,Any,Any}","page":"Home","title":"TangentMps.ibcright","text":"ibcright(O, AR, C; kwargs...)\n\nCompute left infinite boundary condition, defined by\n\n     ┌─            ┌────────┐    ─┐ P    ┌────────┐   ┌────────┐\n─── ┌┘          ───┤   AR   ├───  └┐  ───┤   AR   ├───┤   AR   ├──┐\n    │   ┌┐         └────┬───┘      │     └────┬───┘   └────┬───┘  │\n    │  ─┘│              │          │         .┴────────────.      │\n    │    │  ───         │          │        (       O       )     │\n    │    │              │          │         `┬────────────'      │\n    │  ──┴──       ┌────┴───┐      │     ┌────┴───┐   ┌────┴───┐  │\n─── └┐          ───┤conj(AR)├───  ┌┘  ───┤conj(AR)├───┤conj(AR)├──┘\n     └─            └────────┘    ─┘      └────────┘   └────────┘\n\nReturn values:\n\nibc, info = ibcright(O, AR, C)\n\nArguments:\n\nO: Hamiltonian (only two-site operator is supported)\nAR: right-canonical tensor of mixed-canonical uniform MPS representation\nC: center matrix of mixed-canonical uniform MPS representation\n\nIf O, AR and C is AbstractArray oblect, nothing have to be done. The following methods should be defined:\n\nTangentMps.transfer_from_right(X, O, AR)\nTangentMps.transfer_from_right(X, O, (AR, AR))\nTangentMps.similar_normalized_eye(X)\nBase.*(X, Y)\nBase.*(x::Number, X)\nBase.+(X, Y)\nBase.adjoint(X)\nBase.eltype(X)\nBase.similar(X, [T::Type<:Number])\nBase.fill!(X, α::Number)\nBase.copyto!(X, Y)\nLinearAlgebra.mul!(X, Y, α::Number)\nLinearAlgebra.rmul!(X, α::Number)\nLinearAlgebra.axpy!(α::Number, X, Y)\nLinearAlgebra.axpby!(α::Number, X, β::Number, Y)\nLinearAlgebra.tr(X)\nLinearAlgebra.dot(X,Y)\nLinearAlgebra.norm(X)\n\nwhere typeof(X) == typeof(Y) == typeof(C) is satisfied.\n\nKeyword arguments:\n\nKeyword arguments are passed to KrylovKit.linsolve used in ibc_left.\n\natol::Real: the requested accuracy, i.e. absolute tolerance, on the norm of the   residual.\nrtol::Real: the requested accuracy on the norm of the residual, relative to the norm   of the right hand side b.\ntol::Real: the requested accuracy on the norm of the residual which is actually used,   but which defaults to max(atol, rtol*norm(b)). So either atol and rtol or directly   use tol (in which case the value of atol and rtol will be ignored).\nkrylovdim::Integer: the maximum dimension of the Krylov subspace that will be   constructed.\nmaxiter::Integer: the number of times the Krylov subspace can be rebuilt; see below for   further details on the algorithms.\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.mixedcanonical-Union{Tuple{Array{T,3}}, Tuple{T}} where T","page":"Home","title":"TangentMps.mixedcanonical","text":"mixedcanonical(A)\n\nconvert non-canonical uniform MPS |Ψ(A)⟩ = ∑ vₗ^† (∏ᵢ A^{sᵢ}) vᵣ |{s}⟩ to mixed-canonical uniform MPS |Ψ(AL, AR, AC, C)⟩ = ∑ vₗ^† (∏ᵢ AL^{sᵢ}) AC^{sⱼ} (∏ᵢ AR^{sᵢ}) vᵣ |{s}⟩ = ∑ vₗ^† (∏ᵢ AL^{sᵢ}) C (∏ᵢ AR^{sᵢ}) vᵣ |{s}⟩\n\nReturn values:\n\nAL, AR, AC, C = mixedcanonical(A)\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.mul_matrix_from_left-Tuple{AbstractArray{T,3} where T,AbstractArray{T,2} where T}","page":"Home","title":"TangentMps.mul_matrix_from_left","text":"mul_matrix_from_left(A, X)\n\n  Λ ┌─┐\n─┤X├┤A├─\n  V └┬┘\n     │\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.mul_matrix_from_right-Tuple{AbstractArray{T,3} where T,AbstractArray{T,2} where T}","page":"Home","title":"TangentMps.mul_matrix_from_right","text":"mul_matrix_from_right(A, X)\n\n ┌─┐ Λ\n─┤A├┤X├─\n └┬┘ V\n  │\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.mul_operator_onsite-Tuple{AbstractArray{T,3} where T,AbstractArray{T,2} where T}","page":"Home","title":"TangentMps.mul_operator_onsite","text":"mul_operator_onsite(A, O)\n\n  ┌─┐\n──┤A├──\n  └┬┘\n  .┴.\n ( O )\n  `┬'\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.mul_operator_with_left-Tuple{AbstractArray{T,3} where T,AbstractArray{T,4} where T,AbstractArray{T,3} where T}","page":"Home","title":"TangentMps.mul_operator_with_left","text":"mul_operator_with_left(A, O, AL)\n\n ┌────────┐  ┌─┐\n┌┤   AL   ├──┤A├─┐\n│└────┬───┘  └┬┘ │\n│    .┴───────┴. │\n│   (     O     )│\n│    `┬───────┬' │\n│┌────┴───┐   │  │\n└┤conj(AL)├─┐ │ ┌┘\n └────────┘ │ │ │\n────────────┘ │ └─\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.mul_operator_with_right-Tuple{AbstractArray{T,3} where T,AbstractArray{T,4} where T,AbstractArray{T,3} where T}","page":"Home","title":"TangentMps.mul_operator_with_right","text":"mul_operator_with_right(A, O, AR)\n\n  ┌─┐  ┌────────┐\n┌─┤A├──┤   AR   ├┐\n│ └┬┘  └───┬────┘│\n│ .┴───────┴.    │\n│(     O     )   │\n│ `┬───────┬'    │\n│  │   ┌───┴────┐│\n└┐ │ ┌─┤conj(AR)├┘\n │ │ │ └────────┘\n─┘ │ └────────────\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.tdvpstep-NTuple{6,Any}","page":"Home","title":"TangentMps.tdvpstep","text":"tdvpstep(O, dt, AL, AR, AC, C; kwargs...)\ntdvpstep(O, dt, AL, AC, C; kwargs...) # with inversion symmetry\n\nReturn values:\n\n`(AL, AR, AC, C), norm, (ϵL, ϵR), info = tdvpstep(O, AL, AR, AC, C; kwargs...)`\n`(AL, AC, C), norm, (ϵL,), info = tdvpstep(O, AL, AC, C; kwargs...)`\n\nwhere norm denotes || exp(dt*O)|Ψ(AL, AR, AC, C)⟩ || / || |Ψ(AL, AR, AC, C)⟩ ||\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.transfer_from_left","page":"Home","title":"TangentMps.transfer_from_left","text":"transfer_from_left(X, [O,] (AL, AR), [(BL, BR)=(AL, AR)])\n\n   Λ\n  ╱ ╲  ┌────────┐  ┌────────┐\n┌┤ X ├─┤   AL   ├──┤   AR   ├──\n│ ╲ ╱  └────┬───┘  └────┬───┘\n│  V       .┴───────────┴.\n│         (       O       )\n│          `┬───────────┬'\n│      ┌────┴───┐  ┌────┴───┐\n└──────┤conj(BL)├──┤conj(BR)├─┐\n       └────────┘  └────────┘ │\n──────────────────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"#TangentMps.transfer_from_left","page":"Home","title":"TangentMps.transfer_from_left","text":"transfer_from_left(X, [O,] A, [B=A])\n\n   Λ\n  ╱ ╲  ┌───────┐\n┌┤ X ├─┤   A   ├──\n│ ╲ ╱  └───┬───┘\n│  V      .┴.\n│        ( O )\n│         `┬'\n│      ┌───┴───┐\n└──────│conj(B)│─┐\n       └───────┘ │\n─────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"#TangentMps.transfer_from_right","page":"Home","title":"TangentMps.transfer_from_right","text":"transfer_from_right(X, [O,] (AL, AR), [(BL, BR)=(AL, AR)])\n\n                           Λ\n  ┌────────┐  ┌────────┐  ╱ ╲\n──┤   AL   ├──┤   AR   ├─┤ X ├┐\n  └────┬───┘  └────┬───┘  ╲ ╱ │\n      .┴───────────┴.      V  │\n     (       O       )        │\n      `┬───────────┬'         │\n  ┌────┴───┐  ┌────┴───┐      │\n┌─┤conj(BL)├──┤conj(BR)├──────┘\n│ └────────┘  └────────┘\n└──────────────────────────────\n\n\n\n\n\n","category":"function"},{"location":"#TangentMps.transfer_from_right","page":"Home","title":"TangentMps.transfer_from_right","text":"transfer_from_right(X, [O,] A, [B=A])\n\n              Λ\n  ┌───────┐  ╱ ╲\n──┤   A   ├─┤ X ├─┐\n  └───┬───┘  ╲ ╱  │\n     .┴.      V   │\n    ( O )         │\n     `┬'          │\n  ┌───┴───┐       │\n┌─┤conj(B)├───────┘\n│ └───────┘\n└──────────────────\n\n\n\n\n\n","category":"function"},{"location":"#TangentMps.twosite_variance-Tuple{AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,4} where T}","page":"Home","title":"TangentMps.twosite_variance","text":"twosite_variance(AL, AC, VL, VR, O)\n\n  ┌────────┐    ┌────────┐\n┌─┤   AL   ├────┤   AC   ├─┐\n│ └────┬───┘    └───┬────┘ │\n│    .─┴────────────┴──.   │\n│   (         O         )  │\n│    `─┬────────────┬──'   │\n│ ┌────┴───┐    ┌───┴────┐ │\n└─┤conj(VL)├┐  ┌┤conj(VR)├─┘\n  └────────┘│  │└────────┘\n────────────┘  └────────────\n\n\n\n\n\n","category":"method"},{"location":"#TangentMps.vumpsstep-NTuple{5,Any}","page":"Home","title":"TangentMps.vumpsstep","text":"vumpsstep(O, AL, AR, AC, C; kwargs...)\nvumpsstep(O, AL, AC, C; kwargs...) # with inversion symmetry\n\nReturn values:\n\n`(AL, AR, AC, C), (ϵL, ϵR), info = vumpsstep(O, AL, AR, AC, C; kwargs...)`\n`(AL, AC, C), (ϵL,), info = vumpsstep(O, AL, AC, C; kwargs...)`\n\n\n\n\n\n","category":"method"}]
}
